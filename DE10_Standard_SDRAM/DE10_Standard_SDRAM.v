
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_Standard_SDRAM(

    //////////// CLOCK //////////
    input                               CLOCK2_50,
    input                               CLOCK3_50,
    input                               CLOCK4_50,
    input                               CLOCK_50,

    //////////// KEY push buttons //////////
    input           [3:0]               KEY,

    //////////// SWitches //////////
    input           [9:0]               SW,

    //////////// Seg7 //////////
    output          reg[6:0]            HEX0,
    output          reg[6:0]            HEX1,
    output          reg[6:0]            HEX2,
    output          reg[6:0]            HEX3,
    output          reg[6:0]            HEX4,
    output          reg[6:0]            HEX5,

    //////////// SDRAM //////////
    output          reg[12:0]           DRAM_ADDR,
    output          reg[1:0]            DRAM_BA,
    output          reg                 DRAM_CAS_N,
    output          reg                 DRAM_CKE,
    output          reg                 DRAM_CLK,
    output          reg                 DRAM_CS_N,
    inout           reg[15:0]           DRAM_DQ, // fill this register with data to write, or retrieve data from this register after a read
    output          reg                 DRAM_LDQM,
    output          reg                 DRAM_RAS_N,
    output          reg                 DRAM_UDQM,
    output          reg                 DRAM_WE_N,

    //////////// GPIO, GPIO connect to GPIO Default //////////
    inout           [35:0]              GPIO,
    
    //////////// LED //////////
    output          reg[9:0]            LEDR // after adding the LEDs, do not forget to open the Assignments > Pin Planner and configure the LED
    
);

    `include        "Sdram_Params.h"

//=======================================================
//  REG/WIRE declarations
//=======================================================

    wire                                reset_n;

    wire                                clk;
    wire                                sdram_clk;
    
    // abstract commands
    reg                                 REFRESH;        // reg without specifier: default size: one bit and unsiged
    reg                                 PRECHARGE;
    reg                                 LOAD_MODE;
    reg                                 INIT_REQ;
    reg                                 REF_REQ;
    reg                                 REF_ACK;
    reg                                 READA;
    reg                                 WRITEA;
    reg                                 PM_STOP;
    
    reg                                 do_reada;
    reg                                 do_writea;
    reg                                 do_refresh;
    reg                                 do_precharge;
    reg                                 do_load_mode;
    reg                                 do_initial;
    reg                                 command_done;
    reg     [7:0]                       command_delay;
    reg     [1:0]                       rw_shift;
    reg                                 do_act;
    reg                                 rw_flag;
    reg                                 do_rw;
    reg     [6:0]                       oe_shift;
    reg                                 oe1;
    reg                                 oe2;
    reg                                 oe3;
    reg                                 oe4;
    
    // rp_shift and rp_done are used to time in terms of cycles, when a new command is allowed to start
    reg     [3:0]                       rp_shift; // to create a delay of four cycles, this 4 bit register is filled with 1111 and right shifted. When a 0 appears in the [0] index, rp_done is set to 0 to allow a new command to start 
    reg                                 rp_done; // rp_done is AND-ed together with other flags. A new command can only start when rp_done has a value of 0

    // ???
    reg                                 ex_read; // is set to 1 if the READA command is executed
    reg                                 ex_write; // is set to 1 if the WRITEA command is executed

    reg     [15:0]                      timer;
    reg     [15:0]                      init_timer;
    
    reg     [`ROWSIZE - 1:0]            rowaddr;
    reg     [`COLSIZE - 1:0]            coladdr;
    reg     [`BANKSIZE - 1:0]           bankaddr;

    reg     [7:0]                       debug_reg;
    reg                                 debug_read;
    reg                                 debug_write;
    
//=======================================================
//  Structural coding
//=======================================================

    // PLL
    pll pll_instance(
        .refclk(CLOCK_50),
        .rst(1'b0),
        .outclk_0(clk), // 100 Mhz
        .outclk_1(sdram_clk), // 100 Mhz
        .locked()
    );
    
    assign reset_n = ~KEY[0];

/**/
    // INIT_PER (INITialization PERiod) is a parameter defined inside Sdram_Params.h
    // 
    // INIT_PER is set to 24000 for 100Mhz in Sdram_Params.h
    // The code below works as follow. 
    // The init_timer variable is incremented from 0 to INIT_PER + 201
    //
    // After the initialization process, the SDRAM is ready for reading and writing
    always @(posedge clk or negedge reset_n) begin
    
        if (reset_n == 0) 
            begin
                init_timer      <= 0;
                REFRESH         <= 0;
                PRECHARGE       <= 0; 
                LOAD_MODE       <= 0;
                INIT_REQ        <= 0;
            end
        else 
            begin

                // INIT_PER (INITialization PERiod) is a parameter defined inside Sdram_Params.h
                //
                // the init_timer is increment from 0 to INIT_PER + 201, the it stops
                if (init_timer < (INIT_PER + 201)) 
                    init_timer <= init_timer + 1;                    

                // init_timer within [0, INIT_PER] => execute the INIT_REQ command
                if (init_timer < INIT_PER)
                    begin
                        REFRESH     <= 0;
                        PRECHARGE   <= 0;
                        LOAD_MODE   <= 0;
                        INIT_REQ    <= 1; // there really is no init command defined for SDRAM so this actually triggers ???
                    end

                // init_timer within [INIT_PER, INIT_PER + 20] => execute precharge
                else if (init_timer == (INIT_PER + 20))
                    begin
                        REFRESH     <= 0;
                        PRECHARGE   <= 1; // precharge command
                        LOAD_MODE   <= 0;
                        INIT_REQ    <= 0;
                    end

                // init_timer within [INIT_PER + 20, INIT_PER + 180]
                // init_timer takes on exact values INIT_PER + 40, 60, 80, 100, 120, 140, 160, 180 => refresh
                else if ((init_timer == (INIT_PER + 40))    ||
                         (init_timer == (INIT_PER + 60))    ||
                         (init_timer == (INIT_PER + 80))    ||
                         (init_timer == (INIT_PER + 100))   ||
                         (init_timer == (INIT_PER + 120))   ||
                         (init_timer == (INIT_PER + 140))   ||
                         (init_timer == (INIT_PER + 160))   ||
                         (init_timer == (INIT_PER + 180)))
                    begin
                        REFRESH     <= 1; // refresh command
                        PRECHARGE   <= 0;
                        LOAD_MODE   <= 0;
                        INIT_REQ    <= 0;
                    end

                // init_timer takes on exact values INIT_PER + 200 => Start LOAD
                else if (init_timer == (INIT_PER + 200))
                    begin
                        REFRESH     <= 0;
                        PRECHARGE   <= 0;
                        LOAD_MODE   <= 1; // start the load mode command (Mode Write: S=00, RAS=0, CAS=0, WE=0)
                        INIT_REQ    <= 0;
                    end
                    
                else
                    begin
                        REFRESH     <= 0;
                        PRECHARGE   <= 0;
                        LOAD_MODE   <= 0;
                        INIT_REQ    <= 0;
                    end
            end
    end




    // refresh timer
    //
    // This constantly sends refresh commands to keep the memory powered
    always @(posedge clk or negedge reset_n) 
    begin

        if (reset_n == 0) 
            begin
                timer           <= 0;
                REF_REQ         <= 0;
            end        
        else 
            begin
            
                // REF_ACK (= Refresh request acknowledge)
                if (REF_ACK == 1)
                    begin
                        timer <= REF_PER;
                        REF_REQ <= 0;
                    end
                
                // INIT_REQ (= Hidden initial request)
                else if (INIT_REQ == 1)
                    begin
                        timer <= REF_PER + 200;
                        REF_REQ <= 0;
                    end
                    
                else
                    timer <= timer - 1'b1;

                if (timer == 0)
                    REF_REQ <= 1;
                    
            end

    end

    
    
    
    
    reg [31:0] cont;
    always @(posedge CLOCK_50)
        cont <= (cont == 32'd4_000_001) ? 32'd0 : cont + 1'b1; // increment cont or go back to 0

/* */ 

    //
    // WRITE - key 1
    //
    
    reg[4:0] sample_key1;
    always @(posedge CLOCK_50)
    begin
        if (cont == 32'd4_000_000)
            sample_key1[4:0] = { sample_key1[3:0], KEY[1] }; // left shift old data and insert new data into the index 0
        else 
            sample_key1[4:0] = sample_key1[4:0];
    end
    
    wire write_start_n;
    assign write_start_n = (sample_key1[4:3] == 2'b01) ? 1'b0 : 1'b1;
    
    always @(negedge write_start_n)
    begin
    
        rowaddr <= 32'd0;
        coladdr <= 0;
        bankaddr <= 0;
        
        // value to write
        DRAM_DQ <= debug_reg;
        
        // start a write operation or terminate it
        // HINT: Do not forget to turn off the READA flag as otherwise the system will not be able to run another operation!
        WRITEA <= ~WRITEA;
        LEDR[1] = ~WRITEA;
        
        debug_write <= ~debug_write;
        
        // assign 0 to DRAM_DQ to make sure that the read opeartion actually puts a correct value from SDRAM into DRAM_DQ
        // instead of just outputting the value that was left behind by the write operation
        if (WRITEA == 0)
        begin
            DRAM_DQ <= 0;
        end
    end
    

    
    //
    // READ - key 2
    //
    
    reg[4:0] sample_key2;
    always @(posedge CLOCK_50)
    begin
        if (cont == 32'd4_000_000)
            sample_key2[4:0] = { sample_key2[3:0], KEY[2] }; // left shift old data and insert new data into the index 0
        else 
            sample_key2[4:0] = sample_key2[4:0];
    end
    
    wire  read_start_n;
    assign read_start_n = (sample_key2[4:3] == 2'b01) ? 1'b0 : 1'b1;
    
    reg[15:0] buffer;
    
    always @(negedge read_start_n)
    begin
    
        // start a read operation or terminate it
        // HINT: Do not forget to turn off the READA flag as otherwise the system will not be able to run another operation!
        READA <= ~READA;
        LEDR[2] = ~READA;
        
        debug_read <= ~debug_read;
        
    end

    // write command is done
    always @(negedge WRITEA)
    begin
        HEX0[6:0] = segments(debug_reg);
        debug_reg <= debug_reg + 1;
    end
    
    // read command is done
    always @(negedge READA)
    begin
        HEX5[6:0] = segments(DRAM_DQ);
    end
    
 /*   */
    
    // This always block monitors the individual command lines and issues a command
    // to the next stage if there currently is another command already running.
    //
    always @(posedge clk or negedge reset_n)
    begin

        if (reset_n == 0) 
            begin
                do_reada            <= 0;
                do_writea           <= 0;
                do_refresh          <= 0;
                do_precharge        <= 0;
                do_load_mode        <= 0;
                do_initial          <= 0;
                command_done        <= 0;
                command_delay       <= 0;
                rw_flag             <= 0;
                rp_shift            <= 0;
                rp_done             <= 0;
                ex_read             <= 0;
                ex_write            <= 0;
            end
        else
            begin

                // issue the appropriate command if the sdram is not currently busy
                if ( INIT_REQ == 1 )
                    begin
                        do_reada            <= 0;
                        do_writea           <= 0;
                        do_refresh          <= 0;
                        do_precharge        <= 0;
                        do_load_mode        <= 0;
                        do_initial          <= 1; // the INITIAL command is executed
                        command_done        <= 0;
                        command_delay       <= 0;
                        rw_flag             <= 0;
                        rp_shift            <= 0;
                        rp_done             <= 0;
                        ex_read             <= 0;
                        ex_write            <= 0;
                    end
                else
                    begin
                        do_initial <= 0;

                        // REFRESH
                        if (( REF_REQ == 1 | REFRESH == 1 ) & ( command_done == 0 ) & ( do_refresh == 0 ) & ( rp_done == 0 ) & ( do_reada == 0 ) &  ( do_writea == 0 ))
                            do_refresh <= 1;
                        else
                            do_refresh <= 0;

                        // READA
                        if (( READA == 1 ) & ( command_done == 0 ) & ( do_reada == 0 ) & ( rp_done == 0 ) & ( REF_REQ == 0 ))
                            begin
                                do_reada <= 1;
                                ex_read <= 1;
                            end
                        else
                            do_reada <= 0;

                        // WRITEA
                        if (( WRITEA == 1 ) & ( command_done == 0 ) & ( do_writea == 0 ) & ( rp_done == 0 ) & ( REF_REQ == 0 ))
                            begin
                                do_writea <= 1;
                                ex_write <= 1;
                            end
                        else
                            do_writea <= 0;

                        // PRECHARGE
                        if (( PRECHARGE == 1 ) & ( command_done == 0 ) & ( do_precharge == 0 ))
                            do_precharge <= 1;
                        else
                            do_precharge <= 0;

                        // LOADMODE
                        if (( LOAD_MODE == 1 ) & ( command_done == 0 ) & ( do_load_mode == 0 ))
                            do_load_mode <= 1;
                        else
                            do_load_mode <= 0;

                        // set command_delay shift register and command_done flag
                        //
                        // The command delay shift register is a timer that is used to ensure that
                        // the SDRAM devices have had sufficient time to finish the last command.
                        if (( do_refresh == 1 ) | ( do_reada == 1 ) | ( do_writea == 1 ) | ( do_precharge == 1 ) | ( do_load_mode == 1 ))
                            begin
                                command_delay <= 8'b11111111;
                                command_done <= 1; // command is running
                                
                                rw_flag <= do_reada;
                            end
                        else
                            begin
                            
                                // this will eventually set command_done to zero, because zero are left shifted in
                                command_done <= command_delay[0];
                                
                                // right shift the delay and shift in zeroes from the left
                                command_delay <= ( command_delay >> 1 );
                            end

                        // start additional timer that is used for the refresh, writea, reada commands               
                        if (command_delay[0] == 0 & command_done == 1)
                            begin
                                rp_shift <= 4'b1111;
                                rp_done <= 1;
                            end
                        else
                            begin  
                                if (SC_PM == 0)
                                    begin
                                        rp_shift <= ( rp_shift >> 1 ); // shift left until rp_done[] receives the value 0
                                        rp_done <= rp_shift[0];
                                    end
                                else
                                    begin                        
                                        if (( ex_read == 0 ) && ( ex_write == 0 ))
                                            begin
                                                rp_shift <= ( rp_shift >> 1 ); // shift left until rp_done[] receives the value 0
                                                rp_done <= rp_shift[0];
                                            end
                                        else
                                            begin
                                                // PM_STOP, page mode stop
                                                if (PM_STOP == 1)
                                                    begin
                                                        rp_shift <= ( rp_shift >> 1 ); // shift left until rp_done[] receives the value 0
                                                        rp_done <= rp_shift[0];
                                                        
                                                        ex_read <= 1'b0; // set ex_read to zero
                                                        ex_write <= 1'b0; // set ex_write to zero
                                                    end
                                            end
                                    end
                            end
                    end
            end
    end
    
    // This always block generates the address, cs, cke, and command signals (ras, cas, wen)
    // 
    always @( posedge clk )
    begin

        if (reset_n == 0)
            begin
                DRAM_ADDR   <= 0;       // SDRAM address
                DRAM_BA     <= 0;       // SDRAM bank address
                DRAM_CS_N   <= 1;       // SDRAM chip selects, without this enabled, the SDRAM chip will not talk to anybody
                DRAM_RAS_N  <= 1;       // enable command NOP
                DRAM_CAS_N  <= 1;       // enable command NOP
                DRAM_WE_N   <= 1;       // enable command NOP
                DRAM_CKE    <= 0;       // turn off the clock enable
            end
        else
            begin
            
                // turn on clock enable
                DRAM_CKE <= 1;

                // Generate DRAM_ADDR (= SDRAM address)
                //
                // ACTIVATE command is being issued, so present the row address
                //
                // The ACTIVE command in conjunction with address bits registered are used to select the bank and row to be accessed 
                // (BA0, BA1 select the bank; A0-A12 select the row)
                if (do_writea == 1 | do_reada == 1)
                    DRAM_ADDR <= rowaddr;
                else
                    // else always present column address
                    DRAM_ADDR <= coladdr;

                // set DRAM_ADDR[10] for autoprecharge read/write or for a precharge all command
                // don't set it if the controller is in page mode. 
                if (( do_rw == 1 ) | ( do_precharge ))
                    DRAM_ADDR [ 10 ] <= ! SC_PM;

                // DRAM_BA (= SDRAM bank address)
                if (do_precharge == 1 | do_load_mode == 1)
                    // Set DRAM_BA=0 if performing a precharge or load_mode command
                    DRAM_BA <= 0;
                else
                    // else set it with the appropriate address bits
                    DRAM_BA <= bankaddr [ 1 : 0 ];

                // Select both chip selects if performing
                // refresh, precharge(all) or load_mode
                if (do_refresh == 1 | do_precharge == 1 | do_load_mode == 1 | do_initial == 1)
                    DRAM_CS_N <= 0;
                else
                    begin
//                       DRAM_CS_N[0] <= SADDR[`ASIZE-1];                   // else set the chip selects based off of the
//                       DRAM_CS_N[1] <= ~SADDR[`ASIZE-1];                  // msb address bit
                        DRAM_CS_N <= 0;
                    end               

                // I think this is actually the spot where the value is constructed
                // to configure the MODE register!
                //
                // SDR_CL, SDR_BT, SDR_BL are not defined anywhere!?!?!?!? how does that work?
                // The signals are defined in Sdram_Params.h. They are specific to the SDRAM chip used.
                if (do_load_mode == 1)
                    DRAM_ADDR <= { 2'b00, SDR_CL, SDR_BT, SDR_BL };

                // Generate the appropriate logic levels on DRAM_RAS_N, DRAM_CAS_N, and DRAM_WE_N
                // depending on the issued command.
                
                // Refresh: S=00, RAS=0, CAS=0, WE=1
                if (do_refresh == 1)
                    begin                        
                        DRAM_RAS_N <= 0;
                        DRAM_CAS_N <= 0;
                        DRAM_WE_N <= 1;
                    end
                else

                // burst terminate if write is active
                if (( do_precharge == 1 ) & ( ( oe4 == 1 ) | ( rw_flag == 1 ) ))
                    begin                        
                        DRAM_RAS_N <= 1;
                        DRAM_CAS_N <= 1;
                        DRAM_WE_N <= 0;
                    end
                else

                // Precharge All: S=00, RAS=0, CAS=1, WE=0
                if (do_precharge == 1)
                    begin
                        DRAM_RAS_N <= 0;
                        DRAM_CAS_N <= 1;
                        DRAM_WE_N <= 0;
                    end
                else

                // Mode Write: S=00, RAS=0, CAS=0, WE=0
                // This should be labeled Mode Register Set (MRS) shouldn't it? https://www.mouser.de/datasheet/2/198/42-45R-S_86400F-16320F-706495.pdf page 8, table COMMAND TRUTH TABLE
                if (do_load_mode == 1)
                    begin
                        DRAM_RAS_N <= 0;
                        DRAM_CAS_N <= 0;
                        DRAM_WE_N <= 0;
                    end
                else

                // Activate: S=01 or 10, RAS=0, CAS=1, WE=1
                if (do_reada == 1 | do_writea == 1)
                    begin                        
                        DRAM_RAS_N <= 0;
                        DRAM_CAS_N <= 1;
                        DRAM_WE_N <= 1;
                    end
                else

                // Read/Write: S=01 or 10, RAS=1, CAS=0, WE=0 or 1
                if (do_rw == 1)
                    begin
                        DRAM_RAS_N <= 1;
                        DRAM_CAS_N <= 0;
                        DRAM_WE_N <= rw_flag;
                    end
                else

                if (do_initial == 1)
                    begin
                        // No Operation: RAS=1, CAS=1, WE=1
                        DRAM_RAS_N <= 1;
                        DRAM_CAS_N <= 1;
                        DRAM_WE_N <= 1;
                    end
                else
                    begin
                        // No Operation: RAS=1, CAS=1, WE=1
                        DRAM_RAS_N <= 1;
                        DRAM_CAS_N <= 1;
                        DRAM_WE_N <= 1;
                    end
            end
    end
    
    //
    // Convert a hex nibble, i.e. 0 through F, to a 7 bit variable
    // representing which segments on the 7 segment display should 
    // be lit.
    //
    function automatic [6:0] segments ( input [3:0] i_nibble );

       begin
          
          //
          // Since DE10-Lite board 7 segment displays LEDs
          // are wired active low, the bit patterns below 
          // are negated.  
          //
          // Each 1 in the raw literal value represents 
          // a lit segment.  
          //
          // 'default' case not necessary since list is exhaustive,
          // but good practice to include to ensure avoiding unintentional
          // inferred latch.  Note that this is _combinational_ logic.
          //
          
          case (i_nibble)         // 654 3210 <----- Bit positions based on
             4'h0   : segments = ~7'b011_1111;   //  numbering in comments at
             4'h1   : segments = ~7'b000_0110;   //  top of this module.
             4'h2   : segments = ~7'b101_1011;
             4'h3   : segments = ~7'b100_1111;
             4'h4   : segments = ~7'b110_0110;
             4'h5   : segments = ~7'b110_1101;
             4'h6   : segments = ~7'b111_1101;
             4'h7   : segments = ~7'b000_0111;
             4'h8   : segments = ~7'b111_1111;
             4'h9   : segments = ~7'b110_1111;
             4'hA   : segments = ~7'b111_0111;
             4'hB   : segments = ~7'b111_1100;
             4'hC   : segments = ~7'b011_1001;
             4'hD   : segments = ~7'b101_1110;
             4'hE   : segments = ~7'b111_1001;
             4'hF   : segments = ~7'b111_0001;
             default: segments = ~7'b100_0000;
          endcase
          
       end

    endfunction


endmodule
